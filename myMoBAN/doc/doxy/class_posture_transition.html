<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>MoBAN: PostureTransition Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>PostureTransition Class Reference</h1><!-- doxytag: class="PostureTransition" -->Class to provide spatial and temporal correlation in the posture selection process of the MoBAN mobility model. This class obtains and stores Markovian transition matrices. There is also the possibility to get a steady state vector. In this case, the closest transition matrix to the default Makov matrix is extracted which satisfies the given steady state vector. The class also receives the defined area types and time domains as well as given space-time domains during the initialization phase. During the simulation run, the class provide a functions to return the corresponding markov matrix for a given time and location. It will be used whenever a new posture is going to be selected.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_posture_transition_8h-source.html">PostureTransition.h</a>&gt;</code>
<p>

<p>
<a href="class_posture_transition-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_posture_transition_1_1_area_bound.html">AreaBound</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for one instance of the area (space) boundary.  <a href="struct_posture_transition_1_1_area_bound.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_posture_transition_1_1_area_type.html">AreaType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for one instance of area type.  <a href="struct_posture_transition_1_1_area_type.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_posture_transition_1_1_combination_type.html">CombinationType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for one instance of space-time combination.  <a href="struct_posture_transition_1_1_combination_type.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_posture_transition_1_1_time_bound.html">TimeBound</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for one instance of the time boundary.  <a href="struct_posture_transition_1_1_time_bound.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_posture_transition_1_1_time_domain_type.html">TimeDomainType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for one instance of time domain.  <a href="struct_posture_transition_1_1_time_domain_type.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_posture_transition_1_1_trans_matrix.html">TransMatrix</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for one instance of Markov transition matrix.  <a href="struct_posture_transition_1_1_trans_matrix.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#4b10c46a88e6be413c7395c06bf65380">PostureTransition</a> (int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a posture transition object. The parameter is the number of postures which is the dimension of all matrices.  <a href="#4b10c46a88e6be413c7395c06bf65380"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#2f02ecf5282c7bd2f124a814c9abaa47">addMatrix</a> (std::string, double **, bool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receives a transition matrix and add to the list.  <a href="#2f02ecf5282c7bd2f124a814c9abaa47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#c5c424a8372a3d6f39ccc06c88d4249f">addSteadyState</a> (std::string, double *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receives a steady state vector, extracts the corresponding transition matrix considering the default matrix, and add to the list of given matrices.  <a href="#c5c424a8372a3d6f39ccc06c88d4249f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#261ad915b2a9c7cdf7082660360190e4">addAreaType</a> (std::string)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a area type to the list with the given name and returns the index of this area type in the list.  <a href="#261ad915b2a9c7cdf7082660360190e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#309ed6acf7eca6469f0ea0f06ee41780">setAreaBoundry</a> (int, Coord, Coord)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the given boundary to the existing area type specified by the given ID .  <a href="#309ed6acf7eca6469f0ea0f06ee41780"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#58c7924dfb8810ba37311217a7ba5c8d">addTimeDomain</a> (std::string)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a time domain to the list with the given name and returns the index of the this time domain in the list.  <a href="#58c7924dfb8810ba37311217a7ba5c8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#f66d8f9dda835d55dc3009cf582f87d8">setTimeBoundry</a> (int, simtime_t, simtime_t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds the given boundary to the existing time domain specified by the given ID .  <a href="#f66d8f9dda835d55dc3009cf582f87d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#5b4ab00961c0039aac63143d28e88272">addCombination</a> (std::string, std::string, std::string)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a space-time combination to the list.  <a href="#5b4ab00961c0039aac63143d28e88272"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#1f04b24b643026f15fbc95d175429c5f">getMatrix</a> (simtime_t, Coord)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a time and location, and returns the corresponding Markov transition matrix.  <a href="#1f04b24b643026f15fbc95d175429c5f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector<br class="typebreak">
&lt; <a class="el" href="struct_posture_transition_1_1_trans_matrix.html">TransMatrix</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#7c9e0f2800e1fa2b681ed55c07eb8046">TransMatrixList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for a list of Markov transition matrices.  <a href="#7c9e0f2800e1fa2b681ed55c07eb8046"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector&lt; <a class="el" href="struct_posture_transition_1_1_area_type.html">AreaType</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#98b2ed7203b32614bd82d29079db59cc">AreaTypeList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for the list of area types.  <a href="#98b2ed7203b32614bd82d29079db59cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector<br class="typebreak">
&lt; <a class="el" href="struct_posture_transition_1_1_time_domain_type.html">TimeDomainType</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#867c3cd2530e28d6f2953508a700ffec">TimeDomainList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for the list of time domains.  <a href="#867c3cd2530e28d6f2953508a700ffec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector<br class="typebreak">
&lt; <a class="el" href="struct_posture_transition_1_1_combination_type.html">CombinationType</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#03a03987992fffd49db8174cf6e83953">CombinationList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data type for the list of space-time combinations.  <a href="#03a03987992fffd49db8174cf6e83953"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#3ddddcbf58ad8e1edd23cf8023c7b974">extractMatrixFromSteadyState</a> (double *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a steady state vector and return a matrix which is as close as posible to the default matrix and satisfies the given steady state.  <a href="#3ddddcbf58ad8e1edd23cf8023c7b974"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#e252301f9e6668f04fad293321f55066">findTimeDomain</a> (simtime_t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a time and finds the ID of the containing time domain if there is. If not, return -1.  <a href="#e252301f9e6668f04fad293321f55066"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#299b33afdc27f467b3cdd472a397bb5a">findAreaType</a> (Coord)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a location and finds the ID of the containing area type if there is. If not, return -1.  <a href="#299b33afdc27f467b3cdd472a397bb5a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#be806a2afdeb239694094c24446f699f">isMarkovian</a> (double **)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if a matrix can be a Markov transition matrix. All elements should be in the range [0,1] and elements of each column of the matrix should add up to 1.  <a href="#be806a2afdeb239694094c24446f699f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#67a8cc00702db7106fc5b38447398856">isMarkovian</a> (double *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if a vector can be the steady state of a Markov chain. All elements should be in the range [0,1] and the sum of elements should be 1.  <a href="#67a8cc00702db7106fc5b38447398856"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#be7336508b8864deeb66872425662587">multMatrix</a> (double **, double **, double **)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies two matrices with dimension numPos*numPose .  <a href="#be7336508b8864deeb66872425662587"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#10abfb612543bbc52f6a13a0e138d822">addMatrix</a> (double **, double **, double **)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds two matrices with dimension numPos*numPose .  <a href="#10abfb612543bbc52f6a13a0e138d822"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#f48e8ee3a857b2425a9f1fe6ded08841">subtractMatrix</a> (double **, double **, double **)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtracts two matrices with dimension numPos*numPose .  <a href="#f48e8ee3a857b2425a9f1fe6ded08841"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#2781afe68489f9278e755429787b22ec">multVector</a> (double *, double **)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply a vector of size numPos with its transpose.  <a href="#2781afe68489f9278e755429787b22ec"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73">numPos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of postures.  <a href="#88d4a9fb3d68fb6792ebade157067d73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#e24e4f7a9dc7453d935b87669a0edf24">defaultMatrixID</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The index of the default (base) transition matrix. If no default is set, the first matrix is supposed as the default. Default matrix is used for the cases that a time or space domain does not lie in any given area types or time domains. It is also used for generating the transition matrix in the case that a steady state vector is given for a space-time domain.  <a href="#e24e4f7a9dc7453d935b87669a0edf24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_posture_transition.html#7c9e0f2800e1fa2b681ed55c07eb8046">TransMatrixList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#16d12fd657a13f5a43f5b9d1dd6fea7a">matrixList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The list of all given transition matrices.  <a href="#16d12fd657a13f5a43f5b9d1dd6fea7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_posture_transition.html#98b2ed7203b32614bd82d29079db59cc">AreaTypeList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#438b1e6813a28c3b9b49ae4ecef1b937">areaTypeList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The list of all defined area types.  <a href="#438b1e6813a28c3b9b49ae4ecef1b937"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_posture_transition.html#867c3cd2530e28d6f2953508a700ffec">TimeDomainList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#0566260a55d34fde7d6e35103f95785a">timeDomainList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The list of all defined time domains.  <a href="#0566260a55d34fde7d6e35103f95785a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_posture_transition.html#03a03987992fffd49db8174cf6e83953">CombinationList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_posture_transition.html#b4afd59bcc62d7e198bebff13c873746">combinationList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The list of all given space-time combinations.  <a href="#b4afd59bcc62d7e198bebff13c873746"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class to provide spatial and temporal correlation in the posture selection process of the MoBAN mobility model. This class obtains and stores Markovian transition matrices. There is also the possibility to get a steady state vector. In this case, the closest transition matrix to the default Makov matrix is extracted which satisfies the given steady state vector. The class also receives the defined area types and time domains as well as given space-time domains during the initialization phase. During the simulation run, the class provide a functions to return the corresponding markov matrix for a given time and location. It will be used whenever a new posture is going to be selected. 
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Majid Nabi </dd></dl>

<p>Definition at line <a class="el" href="_posture_transition_8h-source.html#l00040">40</a> of file <a class="el" href="_posture_transition_8h-source.html">PostureTransition.h</a>.</p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="98b2ed7203b32614bd82d29079db59cc"></a><!-- doxytag: member="PostureTransition::AreaTypeList" ref="98b2ed7203b32614bd82d29079db59cc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="struct_posture_transition_1_1_area_type.html">AreaType</a>*&gt; <a class="el" href="class_posture_transition.html#98b2ed7203b32614bd82d29079db59cc">PostureTransition::AreaTypeList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Data type for the list of area types. 
<p>

<p>Definition at line <a class="el" href="_posture_transition_8h-source.html#l00077">77</a> of file <a class="el" href="_posture_transition_8h-source.html">PostureTransition.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="03a03987992fffd49db8174cf6e83953"></a><!-- doxytag: member="PostureTransition::CombinationList" ref="03a03987992fffd49db8174cf6e83953" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="struct_posture_transition_1_1_combination_type.html">CombinationType</a>*&gt; <a class="el" href="class_posture_transition.html#03a03987992fffd49db8174cf6e83953">PostureTransition::CombinationList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Data type for the list of space-time combinations. 
<p>

<p>Definition at line <a class="el" href="_posture_transition_8h-source.html#l00108">108</a> of file <a class="el" href="_posture_transition_8h-source.html">PostureTransition.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="867c3cd2530e28d6f2953508a700ffec"></a><!-- doxytag: member="PostureTransition::TimeDomainList" ref="867c3cd2530e28d6f2953508a700ffec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="struct_posture_transition_1_1_time_domain_type.html">TimeDomainType</a>*&gt; <a class="el" href="class_posture_transition.html#867c3cd2530e28d6f2953508a700ffec">PostureTransition::TimeDomainList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Data type for the list of time domains. 
<p>

<p>Definition at line <a class="el" href="_posture_transition_8h-source.html#l00095">95</a> of file <a class="el" href="_posture_transition_8h-source.html">PostureTransition.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="7c9e0f2800e1fa2b681ed55c07eb8046"></a><!-- doxytag: member="PostureTransition::TransMatrixList" ref="7c9e0f2800e1fa2b681ed55c07eb8046" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="struct_posture_transition_1_1_trans_matrix.html">TransMatrix</a>*&gt; <a class="el" href="class_posture_transition.html#7c9e0f2800e1fa2b681ed55c07eb8046">PostureTransition::TransMatrixList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Data type for a list of Markov transition matrices. 
<p>

<p>Definition at line <a class="el" href="_posture_transition_8h-source.html#l00059">59</a> of file <a class="el" href="_posture_transition_8h-source.html">PostureTransition.h</a>.</p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="4b10c46a88e6be413c7395c06bf65380"></a><!-- doxytag: member="PostureTransition::PostureTransition" ref="4b10c46a88e6be413c7395c06bf65380" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostureTransition::PostureTransition           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numPosture</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a posture transition object. The parameter is the number of postures which is the dimension of all matrices. 
<p>
Constructor function of the class. It sets the value for t he number of posture. It also suppose the first given transition matrix as default. However, during parsing the xml configuration file, if a matrix has attribute type with value "default", it will be considered as the default (base) transition matrix. 
<p>Definition at line <a class="el" href="_posture_transition_8cc-source.html#l00033">33</a> of file <a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00034"></a>00034 {
<a name="l00035"></a>00035         <a class="code" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a> = numPosture;
<a name="l00036"></a>00036         <a class="code" href="class_posture_transition.html#e24e4f7a9dc7453d935b87669a0edf24" title="The index of the default (base) transition matrix. If no default is set, the first...">defaultMatrixID</a> = 0; <span class="comment">// if no default matrix found, the first one will be supposed as the default matrix.</span>
<a name="l00037"></a>00037 }
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="261ad915b2a9c7cdf7082660360190e4"></a><!-- doxytag: member="PostureTransition::addAreaType" ref="261ad915b2a9c7cdf7082660360190e4" args="(std::string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PostureTransition::addAreaType           </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a area type to the list with the given name and returns the index of this area type in the list. 
<p>
Creates a new area type instance and adds it to the list. The boundaries of the area type is empty now. It will be filled later. The function returns the index of the new area type in the list as its output. 
<p>Definition at line <a class="el" href="_posture_transition_8cc-source.html#l00124">124</a> of file <a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00125"></a>00125 {
<a name="l00126"></a>00126 
<a name="l00127"></a>00127         <span class="comment">//Check if the name is repetitive</span>
<a name="l00128"></a>00128         AreaTypeList::const_iterator areaIt;
<a name="l00129"></a>00129         <span class="keywordflow">for</span> (areaIt = <a class="code" href="class_posture_transition.html#438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.begin(); areaIt != <a class="code" href="class_posture_transition.html#438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.end(); areaIt++)
<a name="l00130"></a>00130         {
<a name="l00131"></a>00131                 <span class="keywordflow">if</span> ((*areaIt)-&gt;name == name )
<a name="l00132"></a>00132                 {
<a name="l00133"></a>00133                         std::string str = <span class="stringliteral">"There are multiple area types with the same name: "</span> + name + <span class="stringliteral">" in the configuration file!"</span>;
<a name="l00134"></a>00134                         opp_error (str.c_str());
<a name="l00135"></a>00135                 }
<a name="l00136"></a>00136         }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138         AreaType* area = <span class="keyword">new</span> AreaType;
<a name="l00139"></a>00139         area-&gt;name = name;
<a name="l00140"></a>00140         <a class="code" href="class_posture_transition.html#438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.push_back(area);
<a name="l00141"></a>00141         <span class="keywordflow">return</span> <a class="code" href="class_posture_transition.html#438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.size()-1;
<a name="l00142"></a>00142 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5b4ab00961c0039aac63143d28e88272"></a><!-- doxytag: member="PostureTransition::addCombination" ref="5b4ab00961c0039aac63143d28e88272" args="(std::string, std::string, std::string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PostureTransition::addCombination           </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>areaName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>timeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>matrixName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a space-time combination to the list. 
<p>
This function creates a new space-time combination instance and adds it to the combinations list. It checks if the given names for area type, time domain, and matrix are previously defined and exist in the corresponding lists. Note that at least area type or time domain should have been specified for a combination. Otherwise the combination is not meaningful. if for example a combination has no area type and just has specified time domain, it means that for the whole simulation area, it will be the same and the proper matrix is selected based on the time. 
<p>Definition at line <a class="el" href="_posture_transition_8cc-source.html#l00198">198</a> of file <a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00199"></a>00199 {
<a name="l00200"></a>00200         <span class="keywordtype">int</span> thisID;
<a name="l00201"></a>00201         CombinationType* comb = <span class="keyword">new</span> CombinationType;
<a name="l00202"></a>00202         comb-&gt;areaID = -1;
<a name="l00203"></a>00203         comb-&gt;timeID = -1;
<a name="l00204"></a>00204         comb-&gt;matrixID = -1;
<a name="l00205"></a>00205 
<a name="l00206"></a>00206         <span class="comment">// look for matching area type name.</span>
<a name="l00207"></a>00207         thisID = 0;
<a name="l00208"></a>00208         AreaTypeList::const_iterator areaIt;
<a name="l00209"></a>00209         <span class="keywordflow">for</span> (areaIt = <a class="code" href="class_posture_transition.html#438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.begin(); areaIt != <a class="code" href="class_posture_transition.html#438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.end(); areaIt++)
<a name="l00210"></a>00210         {
<a name="l00211"></a>00211                 <span class="keywordflow">if</span> (areaName == (*areaIt)-&gt;name )
<a name="l00212"></a>00212                 {
<a name="l00213"></a>00213                         comb-&gt;areaID = thisID;
<a name="l00214"></a>00214                         <span class="keywordflow">break</span>;
<a name="l00215"></a>00215                 }
<a name="l00216"></a>00216                 ++thisID;
<a name="l00217"></a>00217         }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219         <span class="comment">// in the input name is empty, it means that no area type is specified for this combination.</span>
<a name="l00220"></a>00220         <span class="keywordflow">if</span> (comb-&gt;areaID == -1 &amp;&amp; !areaName.empty())
<a name="l00221"></a>00221         {
<a name="l00222"></a>00222                 std::string str = <span class="stringliteral">"Undefined area type name is given in a combinations: "</span> + areaName + <span class="stringliteral">", "</span> + timeName + <span class="stringliteral">", "</span> + matrixName;
<a name="l00223"></a>00223                 opp_error (str.c_str());
<a name="l00224"></a>00224         }
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 
<a name="l00227"></a>00227         <span class="comment">// look for matching time domain name.</span>
<a name="l00228"></a>00228         thisID = 0;
<a name="l00229"></a>00229         TimeDomainList::const_iterator timeIt;
<a name="l00230"></a>00230         <span class="keywordflow">for</span> (timeIt = <a class="code" href="class_posture_transition.html#0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.begin(); timeIt != <a class="code" href="class_posture_transition.html#0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.end(); timeIt++)
<a name="l00231"></a>00231         {
<a name="l00232"></a>00232                 <span class="keywordflow">if</span> (timeName == (*timeIt)-&gt;name )
<a name="l00233"></a>00233                 {
<a name="l00234"></a>00234                         comb-&gt;timeID = thisID;
<a name="l00235"></a>00235                         <span class="keywordflow">break</span>;
<a name="l00236"></a>00236                 }
<a name="l00237"></a>00237                 ++thisID;
<a name="l00238"></a>00238         }
<a name="l00239"></a>00239         <span class="keywordflow">if</span> (comb-&gt;timeID == -1 &amp;&amp; !timeName.empty())
<a name="l00240"></a>00240         {
<a name="l00241"></a>00241                 std::string str = <span class="stringliteral">"Undefined time domain name is given in a combinations: "</span> + areaName + <span class="stringliteral">", "</span> + timeName + <span class="stringliteral">", "</span> + matrixName;
<a name="l00242"></a>00242                 opp_error (str.c_str());
<a name="l00243"></a>00243         }
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 
<a name="l00246"></a>00246         <span class="keywordflow">if</span> (comb-&gt;areaID == -1 &amp;&amp; comb-&gt;timeID == -1)
<a name="l00247"></a>00247                 opp_error (<span class="stringliteral">"Both area type and time domain is unspecified in a combination."</span> );
<a name="l00248"></a>00248 
<a name="l00249"></a>00249         <span class="comment">// look for matching transition matrix name.</span>
<a name="l00250"></a>00250         thisID = 0;
<a name="l00251"></a>00251         TransMatrixList::const_iterator matrixIt;
<a name="l00252"></a>00252         <span class="keywordflow">for</span> (matrixIt = <a class="code" href="class_posture_transition.html#16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.begin(); matrixIt != <a class="code" href="class_posture_transition.html#16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.end(); matrixIt++)
<a name="l00253"></a>00253         {
<a name="l00254"></a>00254                 <span class="keywordflow">if</span> (matrixName == (*matrixIt)-&gt;name )
<a name="l00255"></a>00255                 {
<a name="l00256"></a>00256                         comb-&gt;matrixID = thisID;
<a name="l00257"></a>00257                         <span class="keywordflow">break</span>;
<a name="l00258"></a>00258                 }
<a name="l00259"></a>00259                 ++thisID;
<a name="l00260"></a>00260         }
<a name="l00261"></a>00261         <span class="keywordflow">if</span> (comb-&gt;matrixID == -1)
<a name="l00262"></a>00262                 opp_error (<span class="stringliteral">"Undefined matrix name is given in the combinations"</span> );
<a name="l00263"></a>00263 
<a name="l00264"></a>00264         <a class="code" href="class_posture_transition.html#b4afd59bcc62d7e198bebff13c873746" title="The list of all given space-time combinations.">combinationList</a>.push_back(comb);
<a name="l00265"></a>00265 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2f02ecf5282c7bd2f124a814c9abaa47"></a><!-- doxytag: member="PostureTransition::addMatrix" ref="2f02ecf5282c7bd2f124a814c9abaa47" args="(std::string, double **, bool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PostureTransition::addMatrix           </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>thisDefault</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receives a transition matrix and add to the list. 
<p>
This function initiates a new instance of markov matrix with the given matrix. Note that it copies the matrix into the created matrix. The function first verifies if the given matrix can be a Markov transition matrix. 
<p>Definition at line <a class="el" href="_posture_transition_8cc-source.html#l00043">43</a> of file <a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00044"></a>00044 {
<a name="l00045"></a>00045 
<a name="l00046"></a>00046         <span class="comment">//check if the name is repetitive</span>
<a name="l00047"></a>00047         TransMatrixList::const_iterator matrixIt;
<a name="l00048"></a>00048         <span class="keywordflow">for</span> (matrixIt = <a class="code" href="class_posture_transition.html#16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.begin(); matrixIt != <a class="code" href="class_posture_transition.html#16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.end(); matrixIt++)
<a name="l00049"></a>00049         {
<a name="l00050"></a>00050                 <span class="keywordflow">if</span> ((*matrixIt)-&gt;name == name )
<a name="l00051"></a>00051                 {
<a name="l00052"></a>00052                         std::string str = <span class="stringliteral">"There are multiple matrices with the same name: "</span> + name + <span class="stringliteral">" in the configuration file!"</span>;
<a name="l00053"></a>00053                         opp_error (str.c_str());
<a name="l00054"></a>00054                 }
<a name="l00055"></a>00055         }
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 
<a name="l00058"></a>00058         <span class="comment">// verify if the given matrix is Markovian</span>
<a name="l00059"></a>00059         <span class="keywordflow">if</span> ( !<a class="code" href="class_posture_transition.html#be806a2afdeb239694094c24446f699f" title="Checks if a matrix can be a Markov transition matrix. All elements should be in the...">isMarkovian</a>(matrix) )
<a name="l00060"></a>00060         {
<a name="l00061"></a>00061                 std::string str = <span class="stringliteral">"Given transition matrix "</span> + name + <span class="stringliteral">" is not Markovian!"</span>;
<a name="l00062"></a>00062                 opp_error (str.c_str());
<a name="l00063"></a>00063         }
<a name="l00064"></a>00064 
<a name="l00065"></a>00065         TransMatrix* mat = <span class="keyword">new</span> TransMatrix;
<a name="l00066"></a>00066 
<a name="l00067"></a>00067         mat-&gt;name = name;
<a name="l00068"></a>00068         mat-&gt;matrix = <span class="keyword">new</span> <span class="keywordtype">double</span>* [<a class="code" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
<a name="l00069"></a>00069         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;<a class="code" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>;++i)
<a name="l00070"></a>00070         {
<a name="l00071"></a>00071                 mat-&gt;matrix[i] = <span class="keyword">new</span> <span class="keywordtype">double</span> [numPos];
<a name="l00072"></a>00072                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;numPos;++j)
<a name="l00073"></a>00073                         mat-&gt;matrix[i][j] = matrix[i][j];
<a name="l00074"></a>00074         }
<a name="l00075"></a>00075 
<a name="l00076"></a>00076         <a class="code" href="class_posture_transition.html#16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.push_back(mat);
<a name="l00077"></a>00077 
<a name="l00078"></a>00078         <span class="keywordflow">if</span> (thisDefault)
<a name="l00079"></a>00079                 <a class="code" href="class_posture_transition.html#e24e4f7a9dc7453d935b87669a0edf24" title="The index of the default (base) transition matrix. If no default is set, the first...">defaultMatrixID</a> = <a class="code" href="class_posture_transition.html#16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.size()-1;
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="10abfb612543bbc52f6a13a0e138d822"></a><!-- doxytag: member="PostureTransition::addMatrix" ref="10abfb612543bbc52f6a13a0e138d822" args="(double **, double **, double **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostureTransition::addMatrix           </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds two matrices with dimension numPos*numPose . 
<p>
Function to add two matrix with the known dimensions as number of postures. 
<p>Definition at line <a class="el" href="_posture_transition_8cc-source.html#l00411">411</a> of file <a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00412"></a>00412 {
<a name="l00413"></a>00413         <span class="keywordtype">int</span> i,j;
<a name="l00414"></a>00414         <span class="keywordflow">for</span>(i=0; i &lt; <a class="code" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; i++)
<a name="l00415"></a>00415         {
<a name="l00416"></a>00416                 <span class="keywordflow">for</span>(j=0; j &lt; numPos ; j++)
<a name="l00417"></a>00417                         res[i][j] = mat1[i][j] + mat2[i][j];
<a name="l00418"></a>00418         }
<a name="l00419"></a>00419 
<a name="l00420"></a>00420 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c5c424a8372a3d6f39ccc06c88d4249f"></a><!-- doxytag: member="PostureTransition::addSteadyState" ref="c5c424a8372a3d6f39ccc06c88d4249f" args="(std::string, double *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PostureTransition::addSteadyState           </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>iVector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receives a steady state vector, extracts the corresponding transition matrix considering the default matrix, and add to the list of given matrices. 
<p>
This function creates a new instance of markov matrix to be filled with a derived matrix from the given steady state vector. The function first verifies if the given vector can be a steady state vector. Then extracts a markov matrix based on that and adds it to the list of given matrices. 
<p>Definition at line <a class="el" href="_posture_transition_8cc-source.html#l00088">88</a> of file <a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00089"></a>00089 {
<a name="l00090"></a>00090         <span class="comment">//check if the name is repetitive</span>
<a name="l00091"></a>00091         TransMatrixList::const_iterator matrixIt;
<a name="l00092"></a>00092         <span class="keywordflow">for</span> (matrixIt = <a class="code" href="class_posture_transition.html#16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.begin(); matrixIt != <a class="code" href="class_posture_transition.html#16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.end(); matrixIt++)
<a name="l00093"></a>00093         {
<a name="l00094"></a>00094                 <span class="keywordflow">if</span> ((*matrixIt)-&gt;name == name )
<a name="l00095"></a>00095                 {
<a name="l00096"></a>00096                         std::string str = <span class="stringliteral">"There are multiple matrices with the same name: "</span> + name + <span class="stringliteral">" in the configuration file!"</span>;
<a name="l00097"></a>00097                         opp_error (str.c_str());
<a name="l00098"></a>00098                 }
<a name="l00099"></a>00099         }
<a name="l00100"></a>00100 
<a name="l00101"></a>00101         <span class="comment">// check if the given matrix is Markovian</span>
<a name="l00102"></a>00102         <span class="keywordflow">if</span> ( !<a class="code" href="class_posture_transition.html#be806a2afdeb239694094c24446f699f" title="Checks if a matrix can be a Markov transition matrix. All elements should be in the...">isMarkovian</a>(iVector) )
<a name="l00103"></a>00103         {
<a name="l00104"></a>00104                 std::string str = <span class="stringliteral">"Given steady state vector "</span> + name + <span class="stringliteral">" cannot be true!"</span>;
<a name="l00105"></a>00105                 opp_error (str.c_str());
<a name="l00106"></a>00106         }
<a name="l00107"></a>00107 
<a name="l00108"></a>00108         <span class="comment">// make a local copy of the input steady state vector</span>
<a name="l00109"></a>00109         <span class="keywordtype">double</span> *steady = <span class="keyword">new</span> <span class="keywordtype">double</span>[<a class="code" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
<a name="l00110"></a>00110         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; ++i)
<a name="l00111"></a>00111                 steady[i] = iVector[i];
<a name="l00112"></a>00112 
<a name="l00113"></a>00113         TransMatrix* mat = <span class="keyword">new</span> TransMatrix;
<a name="l00114"></a>00114         mat-&gt;name = name;
<a name="l00115"></a>00115         mat-&gt;matrix = <a class="code" href="class_posture_transition.html#3ddddcbf58ad8e1edd23cf8023c7b974" title="Gets a steady state vector and return a matrix which is as close as posible to the...">extractMatrixFromSteadyState</a>(steady);
<a name="l00116"></a>00116 
<a name="l00117"></a>00117         <a class="code" href="class_posture_transition.html#16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.push_back(mat);
<a name="l00118"></a>00118 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="58c7924dfb8810ba37311217a7ba5c8d"></a><!-- doxytag: member="PostureTransition::addTimeDomain" ref="58c7924dfb8810ba37311217a7ba5c8d" args="(std::string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PostureTransition::addTimeDomain           </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a time domain to the list with the given name and returns the index of the this time domain in the list. 
<p>
Creates a new time domain instance and adds it to the list. The boundaries of the time domain is empty now. It will be filled later. The function returns the index of the time domain in the list as its output. 
<p>Definition at line <a class="el" href="_posture_transition_8cc-source.html#l00161">161</a> of file <a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00162"></a>00162 {
<a name="l00163"></a>00163         <span class="comment">//Check if the name is repetitive</span>
<a name="l00164"></a>00164         TimeDomainList::const_iterator timeIt;
<a name="l00165"></a>00165         <span class="keywordflow">for</span> (timeIt = <a class="code" href="class_posture_transition.html#0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.begin(); timeIt != <a class="code" href="class_posture_transition.html#0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.end(); timeIt++)
<a name="l00166"></a>00166         {
<a name="l00167"></a>00167                 <span class="keywordflow">if</span> ((*timeIt)-&gt;name == name )
<a name="l00168"></a>00168                 {
<a name="l00169"></a>00169                         std::string str = <span class="stringliteral">"There are multiple time domains with the same name: "</span> + name + <span class="stringliteral">" in the configuration file!"</span>;
<a name="l00170"></a>00170                         opp_error (str.c_str());
<a name="l00171"></a>00171                 }
<a name="l00172"></a>00172         }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174         TimeDomainType* time = <span class="keyword">new</span> TimeDomainType;
<a name="l00175"></a>00175         time-&gt;name = name;
<a name="l00176"></a>00176         <a class="code" href="class_posture_transition.html#0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.push_back(time);
<a name="l00177"></a>00177         <span class="keywordflow">return</span> <a class="code" href="class_posture_transition.html#0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.size()-1;
<a name="l00178"></a>00178 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="3ddddcbf58ad8e1edd23cf8023c7b974"></a><!-- doxytag: member="PostureTransition::extractMatrixFromSteadyState" ref="3ddddcbf58ad8e1edd23cf8023c7b974" args="(double *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ** PostureTransition::extractMatrixFromSteadyState           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a steady state vector and return a matrix which is as close as posible to the default matrix and satisfies the given steady state. 
<p>
This function receives a steady state vector and extracts a Markovian matrix which is as close as possible to the default markov matrix and satisfies the given steady state vector. 
<p>Definition at line <a class="el" href="_posture_transition_8cc-source.html#l00454">454</a> of file <a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00455"></a>00455 {
<a name="l00456"></a>00456         <span class="keywordtype">int</span> i,j;
<a name="l00457"></a>00457         <span class="keywordtype">double</span>** dafaultMat;
<a name="l00458"></a>00458 
<a name="l00459"></a>00459         <span class="comment">//make output matrix and an identity matrix and a temp</span>
<a name="l00460"></a>00460         <span class="keywordtype">double</span>** mat= <span class="keyword">new</span> <span class="keywordtype">double</span>* [<a class="code" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
<a name="l00461"></a>00461         <span class="keywordtype">double</span>** temp1= <span class="keyword">new</span> <span class="keywordtype">double</span>* [<a class="code" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
<a name="l00462"></a>00462         <span class="keywordtype">double</span>** temp2= <span class="keyword">new</span> <span class="keywordtype">double</span>* [<a class="code" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
<a name="l00463"></a>00463         <span class="keywordtype">double</span>** temp3= <span class="keyword">new</span> <span class="keywordtype">double</span>* [<a class="code" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
<a name="l00464"></a>00464         <span class="keywordtype">double</span>** identity = <span class="keyword">new</span> <span class="keywordtype">double</span>* [<a class="code" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
<a name="l00465"></a>00465         <span class="keywordtype">int</span>** change = <span class="keyword">new</span> <span class="keywordtype">int</span>* [<a class="code" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>];
<a name="l00466"></a>00466         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;<a class="code" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>;++i)
<a name="l00467"></a>00467         {
<a name="l00468"></a>00468                 mat[i] = <span class="keyword">new</span> <span class="keywordtype">double</span> [numPos];
<a name="l00469"></a>00469                 temp1[i] = <span class="keyword">new</span> <span class="keywordtype">double</span> [numPos];
<a name="l00470"></a>00470                 temp2[i] = <span class="keyword">new</span> <span class="keywordtype">double</span> [numPos];
<a name="l00471"></a>00471                 temp3[i] = <span class="keyword">new</span> <span class="keywordtype">double</span> [numPos];
<a name="l00472"></a>00472                 identity[i] = <span class="keyword">new</span> <span class="keywordtype">double</span> [numPos];
<a name="l00473"></a>00473                 change[i] = <span class="keyword">new</span> <span class="keywordtype">int</span> [numPos];
<a name="l00474"></a>00474 
<a name="l00475"></a>00475         }
<a name="l00476"></a>00476 
<a name="l00477"></a>00477         <span class="keywordflow">for</span>(i=0; i &lt; numPos; i++)
<a name="l00478"></a>00478                 <span class="keywordflow">for</span>(j=0; j &lt; numPos ; j++)
<a name="l00479"></a>00479                         <span class="keywordflow">if</span> (i==j)
<a name="l00480"></a>00480                                 identity[i][j] = 1;
<a name="l00481"></a>00481                         <span class="keywordflow">else</span>
<a name="l00482"></a>00482                                 identity[i][j] = 0;
<a name="l00483"></a>00483 
<a name="l00484"></a>00484 
<a name="l00485"></a>00485         <span class="keywordtype">double</span>* sum= <span class="keyword">new</span> <span class="keywordtype">double</span> [numPos];
<a name="l00486"></a>00486         <span class="keywordtype">int</span>* changeSum= <span class="keyword">new</span> <span class="keywordtype">int</span> [numPos];
<a name="l00487"></a>00487 
<a name="l00488"></a>00488 
<a name="l00489"></a>00489         dafaultMat = <a class="code" href="class_posture_transition.html#16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.at(<a class="code" href="class_posture_transition.html#e24e4f7a9dc7453d935b87669a0edf24" title="The index of the default (base) transition matrix. If no default is set, the first...">defaultMatrixID</a>)-&gt;matrix;
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 
<a name="l00492"></a>00492         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> numTry=0;numTry&lt;400;++numTry)
<a name="l00493"></a>00493         {
<a name="l00494"></a>00494                 <a class="code" href="class_posture_transition.html#f48e8ee3a857b2425a9f1fe6ded08841" title="Subtracts two matrices with dimension numPos*numPose .">subtractMatrix</a>(identity,dafaultMat,temp1);
<a name="l00495"></a>00495                 <a class="code" href="class_posture_transition.html#2781afe68489f9278e755429787b22ec" title="Multiply a vector of size numPos with its transpose.">multVector</a>(vec,temp2);
<a name="l00496"></a>00496                 <a class="code" href="class_posture_transition.html#be7336508b8864deeb66872425662587" title="Multiplies two matrices with dimension numPos*numPose .">multMatrix</a>(temp1,temp2,temp3);
<a name="l00497"></a>00497                 <a class="code" href="class_posture_transition.html#10abfb612543bbc52f6a13a0e138d822" title="Adds two matrices with dimension numPos*numPose .">addMatrix</a>(dafaultMat,temp3,mat);
<a name="l00498"></a>00498 
<a name="l00499"></a>00499                 <span class="comment">//remember if it has not changed</span>
<a name="l00500"></a>00500                 <span class="keywordflow">for</span>(i=0; i &lt; numPos; i++)
<a name="l00501"></a>00501                         <span class="keywordflow">for</span>(j=0; j &lt; numPos ; j++)
<a name="l00502"></a>00502                                 change[i][j] = 1;
<a name="l00503"></a>00503 
<a name="l00504"></a>00504                 <span class="keywordflow">for</span>(j=0; j &lt; numPos; j++)
<a name="l00505"></a>00505                         <span class="keywordflow">for</span>(i=0; i &lt; numPos ; i++)
<a name="l00506"></a>00506                         {
<a name="l00507"></a>00507                                 <span class="keywordflow">if</span> ( mat[i][j] &lt; 0 ){
<a name="l00508"></a>00508                                         mat[i][j] = 0;
<a name="l00509"></a>00509                                         change[i][j]=0;
<a name="l00510"></a>00510                                 }
<a name="l00511"></a>00511                                 <span class="keywordflow">if</span> ( mat[i][j] &gt; 1 ){
<a name="l00512"></a>00512                                         mat[i][j] = 1;
<a name="l00513"></a>00513                                         change[i][j]=0;
<a name="l00514"></a>00514                                 }
<a name="l00515"></a>00515                         }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 
<a name="l00518"></a>00518                 <span class="keywordflow">for</span>(j=0; j &lt; numPos; j++)
<a name="l00519"></a>00519                 {
<a name="l00520"></a>00520                         sum[j] = 0;
<a name="l00521"></a>00521                         changeSum[j]=0;
<a name="l00522"></a>00522                         <span class="keywordflow">for</span>(i=0; i &lt; numPos ; i++)
<a name="l00523"></a>00523                         {
<a name="l00524"></a>00524                                 sum[j] += mat[i][j];
<a name="l00525"></a>00525                                 changeSum[j] += change[i][j];
<a name="l00526"></a>00526                         }
<a name="l00527"></a>00527                 }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529                 <span class="keywordflow">for</span>(j=0; j &lt; numPos; j++)
<a name="l00530"></a>00530                         <span class="keywordflow">for</span>(i=0; i &lt; numPos ; i++)
<a name="l00531"></a>00531                         {
<a name="l00532"></a>00532                                 <span class="keywordflow">if</span> (change[i][j] == 1)
<a name="l00533"></a>00533                                         mat[i][j] = mat[i][j]+ (1-sum[j])/changeSum[j];
<a name="l00534"></a>00534                         }
<a name="l00535"></a>00535 
<a name="l00536"></a>00536                 dafaultMat = mat;
<a name="l00537"></a>00537         }
<a name="l00538"></a>00538 
<a name="l00539"></a>00539         <span class="keywordflow">for</span>(j=0; j &lt; numPos; j++)
<a name="l00540"></a>00540                 <span class="keywordflow">for</span>(i=0; i &lt; numPos ; i++)
<a name="l00541"></a>00541                 {
<a name="l00542"></a>00542                         <span class="keywordflow">if</span> ( mat[i][j] &lt; 0 )
<a name="l00543"></a>00543                                 mat[i][j] = 0;
<a name="l00544"></a>00544                         <span class="keywordflow">if</span> ( mat[i][j] &gt; 1 )
<a name="l00545"></a>00545                                 mat[i][j] = 1;
<a name="l00546"></a>00546                 }
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 
<a name="l00549"></a>00549         <a class="codeRef" doxygen="opptags.xml:D:\WORK\omnetpp-4.1\/doc/api/" href="D:\WORK\omnetpp-4.1\/doc/api/group__Envir.html#g650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">"Generated Markov matrix from the steady state: "</span>&lt;&lt; endl;
<a name="l00550"></a>00550         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0;k &lt; numPos; ++k)
<a name="l00551"></a>00551         {
<a name="l00552"></a>00552                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> f=0; f&lt;numPos ;++f)
<a name="l00553"></a>00553                         <a class="codeRef" doxygen="opptags.xml:D:\WORK\omnetpp-4.1\/doc/api/" href="D:\WORK\omnetpp-4.1\/doc/api/group__Envir.html#g650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; mat[k][f]&lt;&lt;<span class="stringliteral">"       "</span>;
<a name="l00554"></a>00554                 <a class="codeRef" doxygen="opptags.xml:D:\WORK\omnetpp-4.1\/doc/api/" href="D:\WORK\omnetpp-4.1\/doc/api/group__Envir.html#g650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; endl;
<a name="l00555"></a>00555         }
<a name="l00556"></a>00556 
<a name="l00557"></a>00557         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;numPos;++i)
<a name="l00558"></a>00558         {
<a name="l00559"></a>00559                 <span class="keyword">delete</span> temp1[i]; <span class="keyword">delete</span> temp2[i]; <span class="keyword">delete</span> temp3[i];
<a name="l00560"></a>00560                 <span class="keyword">delete</span> identity[i];
<a name="l00561"></a>00561                 <span class="keyword">delete</span> change[i];
<a name="l00562"></a>00562         }
<a name="l00563"></a>00563         <span class="keyword">delete</span> temp1; <span class="keyword">delete</span> temp2; <span class="keyword">delete</span> temp3;
<a name="l00564"></a>00564         <span class="keyword">delete</span> identity;
<a name="l00565"></a>00565         <span class="keyword">delete</span> change;
<a name="l00566"></a>00566         <span class="keyword">delete</span> sum;
<a name="l00567"></a>00567         <span class="keyword">delete</span> changeSum;
<a name="l00568"></a>00568 
<a name="l00569"></a>00569 
<a name="l00570"></a>00570         <span class="keywordflow">return</span> mat;
<a name="l00571"></a>00571 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="299b33afdc27f467b3cdd472a397bb5a"></a><!-- doxytag: member="PostureTransition::findAreaType" ref="299b33afdc27f467b3cdd472a397bb5a" args="(Coord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PostureTransition::findAreaType           </td>
          <td>(</td>
          <td class="paramtype">Coord&nbsp;</td>
          <td class="paramname"> <em>iLocation</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a location and finds the ID of the containing area type if there is. If not, return -1. 
<p>
Looks for the first containing area type for the given location. It return the Id of the found area type. If no area type is found which contains the given location, it returns -1. 
<p>Definition at line <a class="el" href="_posture_transition_8cc-source.html#l00325">325</a> of file <a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00326"></a>00326 {
<a name="l00327"></a>00327         <span class="keywordtype">int</span> locationID=0;
<a name="l00328"></a>00328         AreaTypeList::const_iterator areaIt;
<a name="l00329"></a>00329         <span class="keywordflow">for</span> (areaIt = <a class="code" href="class_posture_transition.html#438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.begin(); areaIt != <a class="code" href="class_posture_transition.html#438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.end(); areaIt++)
<a name="l00330"></a>00330         {
<a name="l00331"></a>00331                 std::vector&lt;AreaBound*&gt; boundList = (*areaIt)-&gt;boundries;
<a name="l00332"></a>00332 
<a name="l00333"></a>00333                 std::vector&lt;AreaBound*&gt;::const_iterator bound;
<a name="l00334"></a>00334                 <span class="keywordflow">for</span> (bound = boundList.begin(); bound != boundList.end(); bound++)
<a name="l00335"></a>00335                 {
<a name="l00336"></a>00336                         <span class="keywordflow">if</span> ( iLocation.isInBoundary( (*bound)-&gt;low ,(*bound)-&gt;high ) )
<a name="l00337"></a>00337                                 <span class="keywordflow">return</span> locationID;
<a name="l00338"></a>00338                 }
<a name="l00339"></a>00339                 ++locationID;
<a name="l00340"></a>00340         }
<a name="l00341"></a>00341         <a class="codeRef" doxygen="opptags.xml:D:\WORK\omnetpp-4.1\/doc/api/" href="D:\WORK\omnetpp-4.1\/doc/api/group__Envir.html#g650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">"Area Type not found"</span> &lt;&lt; endl;
<a name="l00342"></a>00342         <span class="keywordflow">return</span> -1;
<a name="l00343"></a>00343 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e252301f9e6668f04fad293321f55066"></a><!-- doxytag: member="PostureTransition::findTimeDomain" ref="e252301f9e6668f04fad293321f55066" args="(simtime_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PostureTransition::findTimeDomain           </td>
          <td>(</td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>iTime</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a time and finds the ID of the containing time domain if there is. If not, return -1. 
<p>
Looks for the first containing time domain for the given time instance. It return the Id of the found time domain. If no time domain is found which contains the given time instance, it returns -1. 
<p>Definition at line <a class="el" href="_posture_transition_8cc-source.html#l00301">301</a> of file <a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00302"></a>00302 {
<a name="l00303"></a>00303         <span class="keywordtype">int</span> timeID=0;
<a name="l00304"></a>00304         TimeDomainList::const_iterator timeIt;
<a name="l00305"></a>00305         <span class="keywordflow">for</span> (timeIt = <a class="code" href="class_posture_transition.html#0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.begin(); timeIt != <a class="code" href="class_posture_transition.html#0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.end(); timeIt++)
<a name="l00306"></a>00306         {
<a name="l00307"></a>00307                 std::vector&lt;TimeBound*&gt; boundList = (*timeIt)-&gt;boundries;
<a name="l00308"></a>00308 
<a name="l00309"></a>00309                 std::vector&lt;TimeBound*&gt;::const_iterator bound;
<a name="l00310"></a>00310                 <span class="keywordflow">for</span> (bound = boundList.begin(); bound != boundList.end(); bound++)
<a name="l00311"></a>00311                 {
<a name="l00312"></a>00312                         <span class="keywordflow">if</span> ( iTime &gt;= (*bound)-&gt;low &amp;&amp; iTime &lt; (*bound)-&gt;high)
<a name="l00313"></a>00313                                 <span class="keywordflow">return</span> timeID;
<a name="l00314"></a>00314                 }
<a name="l00315"></a>00315                 ++timeID;
<a name="l00316"></a>00316         }
<a name="l00317"></a>00317         <a class="codeRef" doxygen="opptags.xml:D:\WORK\omnetpp-4.1\/doc/api/" href="D:\WORK\omnetpp-4.1\/doc/api/group__Envir.html#g650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">"Time domain not found"</span> &lt;&lt; endl;
<a name="l00318"></a>00318         <span class="keywordflow">return</span> -1;
<a name="l00319"></a>00319 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1f04b24b643026f15fbc95d175429c5f"></a><!-- doxytag: member="PostureTransition::getMatrix" ref="1f04b24b643026f15fbc95d175429c5f" args="(simtime_t, Coord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ** PostureTransition::getMatrix           </td>
          <td>(</td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>iTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coord&nbsp;</td>
          <td class="paramname"> <em>iLocation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a time and location, and returns the corresponding Markov transition matrix. 
<p>
This function is actually the main usage of this class. It gets a time instance and a location within the simulation area, and then looks for the first fitting combination. If found, it returns the specified Markov transition matrix for that combination as its output. If no combination is found, it returns the default matrix. 
<p>Definition at line <a class="el" href="_posture_transition_8cc-source.html#l00272">272</a> of file <a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00273"></a>00273 {
<a name="l00274"></a>00274         <span class="keywordtype">int</span> timeID,locationID,matrixID;
<a name="l00275"></a>00275 
<a name="l00276"></a>00276         timeID = <a class="code" href="class_posture_transition.html#e252301f9e6668f04fad293321f55066" title="Gets a time and finds the ID of the containing time domain if there is. If not, return...">findTimeDomain</a>(iTime);
<a name="l00277"></a>00277         locationID = <a class="code" href="class_posture_transition.html#299b33afdc27f467b3cdd472a397bb5a" title="Gets a location and finds the ID of the containing area type if there is. If not...">findAreaType</a>(iLocation);
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 
<a name="l00280"></a>00280         matrixID = <a class="code" href="class_posture_transition.html#e24e4f7a9dc7453d935b87669a0edf24" title="The index of the default (base) transition matrix. If no default is set, the first...">defaultMatrixID</a>;
<a name="l00281"></a>00281 
<a name="l00282"></a>00282         CombinationList::const_iterator combIt;
<a name="l00283"></a>00283         <span class="keywordflow">for</span> (combIt = <a class="code" href="class_posture_transition.html#b4afd59bcc62d7e198bebff13c873746" title="The list of all given space-time combinations.">combinationList</a>.begin(); combIt != <a class="code" href="class_posture_transition.html#b4afd59bcc62d7e198bebff13c873746" title="The list of all given space-time combinations.">combinationList</a>.end(); combIt++)
<a name="l00284"></a>00284         {
<a name="l00285"></a>00285                 <span class="keywordflow">if</span> ( (*combIt)-&gt;timeID == timeID &amp;&amp; (*combIt)-&gt;areaID == locationID)
<a name="l00286"></a>00286                 {
<a name="l00287"></a>00287                         matrixID = (*combIt)-&gt;matrixID;
<a name="l00288"></a>00288                         <span class="keywordflow">break</span>;
<a name="l00289"></a>00289                 }
<a name="l00290"></a>00290         }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292         <a class="codeRef" doxygen="opptags.xml:D:\WORK\omnetpp-4.1\/doc/api/" href="D:\WORK\omnetpp-4.1\/doc/api/group__Envir.html#g650ef3eff8a2900bef69dae29c05d2dd">EV</a> &lt;&lt; <span class="stringliteral">"The corresponding Markov matrix for time"</span> &lt;&lt; iTime.dbl() &lt;&lt;<span class="stringliteral">" and location "</span> &lt;&lt; iLocation.info() &lt;&lt; <span class="stringliteral">" is: "</span> &lt;&lt; <a class="code" href="class_posture_transition.html#16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.at(matrixID)-&gt;name &lt;&lt; endl;
<a name="l00293"></a>00293 
<a name="l00294"></a>00294         <span class="keywordflow">return</span> <a class="code" href="class_posture_transition.html#16d12fd657a13f5a43f5b9d1dd6fea7a" title="The list of all given transition matrices.">matrixList</a>.at(matrixID)-&gt;matrix;
<a name="l00295"></a>00295 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="67a8cc00702db7106fc5b38447398856"></a><!-- doxytag: member="PostureTransition::isMarkovian" ref="67a8cc00702db7106fc5b38447398856" args="(double *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PostureTransition::isMarkovian           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if a vector can be the steady state of a Markov chain. All elements should be in the range [0,1] and the sum of elements should be 1. 
<p>
Verifies if a vector can be the steady state of a Markov model. Each element of the matrix should be in the range [0 1]. Further, the sum of all elements should be one. 
<p>Definition at line <a class="el" href="_posture_transition_8cc-source.html#l00373">373</a> of file <a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00374"></a>00374 {
<a name="l00375"></a>00375         <span class="keywordtype">double</span> sumCol=0;
<a name="l00376"></a>00376         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;<a class="code" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>;++i)
<a name="l00377"></a>00377         {
<a name="l00378"></a>00378                 <span class="keywordflow">if</span> (vec[i] &lt; 0 || vec[i]&gt; 1)
<a name="l00379"></a>00379                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00380"></a>00380                 sumCol += vec[i];
<a name="l00381"></a>00381         }
<a name="l00382"></a>00382 
<a name="l00383"></a>00383         <span class="keywordflow">if</span> ( !FWMath::close(sumCol , 1.0 ) )
<a name="l00384"></a>00384                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00385"></a>00385         <span class="keywordflow">else</span>
<a name="l00386"></a>00386                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00387"></a>00387 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="be806a2afdeb239694094c24446f699f"></a><!-- doxytag: member="PostureTransition::isMarkovian" ref="be806a2afdeb239694094c24446f699f" args="(double **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PostureTransition::isMarkovian           </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>matrix</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if a matrix can be a Markov transition matrix. All elements should be in the range [0,1] and elements of each column of the matrix should add up to 1. 
<p>
Verifies if a matrix can be a Markovian transition matrix. Each element of the matrix should be in the range [0 1]. Further, all elements of each column should adds up to one. 
<p>Definition at line <a class="el" href="_posture_transition_8cc-source.html#l00349">349</a> of file <a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00350"></a>00350 {
<a name="l00351"></a>00351         <span class="keywordtype">double</span> sumCol;
<a name="l00352"></a>00352         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;<a class="code" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>;++j)
<a name="l00353"></a>00353         {
<a name="l00354"></a>00354                 sumCol = 0;
<a name="l00355"></a>00355                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;numPos;++i)
<a name="l00356"></a>00356                 {
<a name="l00357"></a>00357                         <span class="keywordflow">if</span> (matrix[i][j] &lt; 0 || matrix[i][j] &gt; 1)
<a name="l00358"></a>00358                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00359"></a>00359                         sumCol += matrix[i][j];
<a name="l00360"></a>00360                 }
<a name="l00361"></a>00361 
<a name="l00362"></a>00362                 <span class="keywordflow">if</span> (!FWMath::close(sumCol , 1.0 ))
<a name="l00363"></a>00363                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00364"></a>00364         }
<a name="l00365"></a>00365 
<a name="l00366"></a>00366         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00367"></a>00367 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="be7336508b8864deeb66872425662587"></a><!-- doxytag: member="PostureTransition::multMatrix" ref="be7336508b8864deeb66872425662587" args="(double **, double **, double **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostureTransition::multMatrix           </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiplies two matrices with dimension numPos*numPose . 
<p>
Function to multiply two matrix with the known dimensions as number of postures. 
<p>Definition at line <a class="el" href="_posture_transition_8cc-source.html#l00392">392</a> of file <a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00393"></a>00393 {
<a name="l00394"></a>00394 
<a name="l00395"></a>00395         <span class="keywordtype">int</span> i,j,l;
<a name="l00396"></a>00396         <span class="keywordflow">for</span>(i=0; i &lt; <a class="code" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; i++)
<a name="l00397"></a>00397         {
<a name="l00398"></a>00398                 <span class="keywordflow">for</span>(j=0; j &lt; numPos ; j++)
<a name="l00399"></a>00399                 {
<a name="l00400"></a>00400                         res[i][j]=0;
<a name="l00401"></a>00401                         <span class="keywordflow">for</span>(l=0; l &lt; numPos ; l++)
<a name="l00402"></a>00402                                 res[i][j] += mat1[i][l] * mat2[l][j];
<a name="l00403"></a>00403                 }
<a name="l00404"></a>00404         }
<a name="l00405"></a>00405 
<a name="l00406"></a>00406 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2781afe68489f9278e755429787b22ec"></a><!-- doxytag: member="PostureTransition::multVector" ref="2781afe68489f9278e755429787b22ec" args="(double *, double **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostureTransition::multVector           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Multiply a vector of size numPos with its transpose. 
<p>
Function to multiply a vector by its transpose (pi . pi^T). The size in equal to the number of postures. 
<p>Definition at line <a class="el" href="_posture_transition_8cc-source.html#l00439">439</a> of file <a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00440"></a>00440 {
<a name="l00441"></a>00441         <span class="keywordtype">int</span> i,j;
<a name="l00442"></a>00442         <span class="keywordflow">for</span>(i=0; i &lt; <a class="code" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; i++)
<a name="l00443"></a>00443         {
<a name="l00444"></a>00444                 <span class="keywordflow">for</span>(j=0; j &lt; numPos ; j++)
<a name="l00445"></a>00445                         res[i][j] = vec[i] * vec[j];
<a name="l00446"></a>00446         }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="309ed6acf7eca6469f0ea0f06ee41780"></a><!-- doxytag: member="PostureTransition::setAreaBoundry" ref="309ed6acf7eca6469f0ea0f06ee41780" args="(int, Coord, Coord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PostureTransition::setAreaBoundry           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coord&nbsp;</td>
          <td class="paramname"> <em>lowBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coord&nbsp;</td>
          <td class="paramname"> <em>highBound</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the given boundary to the existing area type specified by the given ID . 
<p>
This function gets an index of an existing area type and adds the given boundary to the boundary list of that area type. 
<p>Definition at line <a class="el" href="_posture_transition_8cc-source.html#l00147">147</a> of file <a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00148"></a>00148 {
<a name="l00149"></a>00149         AreaBound* bound=<span class="keyword">new</span> AreaBound;
<a name="l00150"></a>00150         bound-&gt;low = lowBound;
<a name="l00151"></a>00151         bound-&gt;high = highBound;
<a name="l00152"></a>00152 
<a name="l00153"></a>00153         <a class="code" href="class_posture_transition.html#438b1e6813a28c3b9b49ae4ecef1b937" title="The list of all defined area types.">areaTypeList</a>.at(<span class="keywordtype">id</span>)-&gt;boundries.push_back(bound);
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f66d8f9dda835d55dc3009cf582f87d8"></a><!-- doxytag: member="PostureTransition::setTimeBoundry" ref="f66d8f9dda835d55dc3009cf582f87d8" args="(int, simtime_t, simtime_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PostureTransition::setTimeBoundry           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>lowBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simtime_t&nbsp;</td>
          <td class="paramname"> <em>highBound</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds the given boundary to the existing time domain specified by the given ID . 
<p>
This function gets an index of an existing time domain and adds the given boundary to the boundary list of that time domain. 
<p>Definition at line <a class="el" href="_posture_transition_8cc-source.html#l00183">183</a> of file <a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00184"></a>00184 {
<a name="l00185"></a>00185         TimeBound* bound=<span class="keyword">new</span> TimeBound;
<a name="l00186"></a>00186         bound-&gt;low = lowBound;
<a name="l00187"></a>00187         bound-&gt;high = highBound;
<a name="l00188"></a>00188 
<a name="l00189"></a>00189         <a class="code" href="class_posture_transition.html#0566260a55d34fde7d6e35103f95785a" title="The list of all defined time domains.">timeDomainList</a>.at(<span class="keywordtype">id</span>)-&gt;boundries.push_back(bound);
<a name="l00190"></a>00190 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f48e8ee3a857b2425a9f1fe6ded08841"></a><!-- doxytag: member="PostureTransition::subtractMatrix" ref="f48e8ee3a857b2425a9f1fe6ded08841" args="(double **, double **, double **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostureTransition::subtractMatrix           </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>mat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subtracts two matrices with dimension numPos*numPose . 
<p>
Function to subtract two matrix with the known dimensions as number of postures. 
<p>Definition at line <a class="el" href="_posture_transition_8cc-source.html#l00425">425</a> of file <a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00426"></a>00426 {
<a name="l00427"></a>00427         <span class="keywordtype">int</span> i,j;
<a name="l00428"></a>00428         <span class="keywordflow">for</span>(i=0; i &lt; <a class="code" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73" title="Number of postures.">numPos</a>; i++)
<a name="l00429"></a>00429         {
<a name="l00430"></a>00430                 <span class="keywordflow">for</span>(j=0; j &lt; numPos ; j++)
<a name="l00431"></a>00431                         res[i][j] = mat1[i][j] - mat2[i][j];
<a name="l00432"></a>00432         }
<a name="l00433"></a>00433 
<a name="l00434"></a>00434 }
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="438b1e6813a28c3b9b49ae4ecef1b937"></a><!-- doxytag: member="PostureTransition::areaTypeList" ref="438b1e6813a28c3b9b49ae4ecef1b937" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_posture_transition.html#98b2ed7203b32614bd82d29079db59cc">AreaTypeList</a> <a class="el" href="class_posture_transition.html#438b1e6813a28c3b9b49ae4ecef1b937">PostureTransition::areaTypeList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The list of all defined area types. 
<p>

<p>Definition at line <a class="el" href="_posture_transition_8h-source.html#l00080">80</a> of file <a class="el" href="_posture_transition_8h-source.html">PostureTransition.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b4afd59bcc62d7e198bebff13c873746"></a><!-- doxytag: member="PostureTransition::combinationList" ref="b4afd59bcc62d7e198bebff13c873746" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_posture_transition.html#03a03987992fffd49db8174cf6e83953">CombinationList</a> <a class="el" href="class_posture_transition.html#b4afd59bcc62d7e198bebff13c873746">PostureTransition::combinationList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The list of all given space-time combinations. 
<p>

<p>Definition at line <a class="el" href="_posture_transition_8h-source.html#l00111">111</a> of file <a class="el" href="_posture_transition_8h-source.html">PostureTransition.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="e24e4f7a9dc7453d935b87669a0edf24"></a><!-- doxytag: member="PostureTransition::defaultMatrixID" ref="e24e4f7a9dc7453d935b87669a0edf24" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_posture_transition.html#e24e4f7a9dc7453d935b87669a0edf24">PostureTransition::defaultMatrixID</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The index of the default (base) transition matrix. If no default is set, the first matrix is supposed as the default. Default matrix is used for the cases that a time or space domain does not lie in any given area types or time domains. It is also used for generating the transition matrix in the case that a steady state vector is given for a space-time domain. 
<p>

<p>Definition at line <a class="el" href="_posture_transition_8h-source.html#l00050">50</a> of file <a class="el" href="_posture_transition_8h-source.html">PostureTransition.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="16d12fd657a13f5a43f5b9d1dd6fea7a"></a><!-- doxytag: member="PostureTransition::matrixList" ref="16d12fd657a13f5a43f5b9d1dd6fea7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_posture_transition.html#7c9e0f2800e1fa2b681ed55c07eb8046">TransMatrixList</a> <a class="el" href="class_posture_transition.html#16d12fd657a13f5a43f5b9d1dd6fea7a">PostureTransition::matrixList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The list of all given transition matrices. 
<p>

<p>Definition at line <a class="el" href="_posture_transition_8h-source.html#l00062">62</a> of file <a class="el" href="_posture_transition_8h-source.html">PostureTransition.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="88d4a9fb3d68fb6792ebade157067d73"></a><!-- doxytag: member="PostureTransition::numPos" ref="88d4a9fb3d68fb6792ebade157067d73" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_posture_transition.html#88d4a9fb3d68fb6792ebade157067d73">PostureTransition::numPos</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of postures. 
<p>

<p>Definition at line <a class="el" href="_posture_transition_8h-source.html#l00044">44</a> of file <a class="el" href="_posture_transition_8h-source.html">PostureTransition.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="0566260a55d34fde7d6e35103f95785a"></a><!-- doxytag: member="PostureTransition::timeDomainList" ref="0566260a55d34fde7d6e35103f95785a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_posture_transition.html#867c3cd2530e28d6f2953508a700ffec">TimeDomainList</a> <a class="el" href="class_posture_transition.html#0566260a55d34fde7d6e35103f95785a">PostureTransition::timeDomainList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The list of all defined time domains. 
<p>

<p>Definition at line <a class="el" href="_posture_transition_8h-source.html#l00098">98</a> of file <a class="el" href="_posture_transition_8h-source.html">PostureTransition.h</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_posture_transition_8h-source.html">PostureTransition.h</a><li><a class="el" href="_posture_transition_8cc-source.html">PostureTransition.cc</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Mar 18 10:12:44 2011 for MoBAN by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
